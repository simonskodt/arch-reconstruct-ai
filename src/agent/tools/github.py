"""
This file defines a tool to clone GitHub repositories using GitPython.
"""
import os
import shutil
import json
from typing import Optional, Dict, Any
from git import Repo, GitCommandError
from git.exc import NoSuchPathError, InvalidGitRepositoryError
from langchain.tools import tool
from gitingest import ingest_async
from config import GITINGEST_DEFAULT_OUTPUT_LOCATION

@tool("git_clone")
def git_clone_tool(
    repo_url: str,
    dest: str,
    branch: Optional[str] = None,
    overwrite: bool = False,
) -> Dict[str, Any]:
    """
    Clone a Git repository into ./repositories/{dest}.

    Args:
        repo_url: HTTPS or SSH URL of the repository.
        dest: Name of the destination folder for the clone inside ./repositories/.
        branch: Optional branch to check out.
        overwrite: If True, overwrite existing destination folder.
    Returns:
        A dict with success (bool), dest (str), and error/stdout messages.
    """

    try:
        # Ensure repositories/ root exists
        root_dir = os.path.join(os.getcwd(), "repositories")
        os.makedirs(root_dir, exist_ok=True)

        # Full destination path inside repositories/
        full_dest = os.path.join(root_dir, dest)

        # Handle overwrite
        if os.path.exists(full_dest):
            if overwrite:
                shutil.rmtree(full_dest)
            else:
                return {"success": False, "error": f"Destination {full_dest} already exists."}


        # Clone options
        kwargs = {}
        if branch:
            kwargs["branch"] = branch
            full_dest = f"{full_dest}/{branch}"

        os.makedirs(full_dest, exist_ok=True)
        repo = Repo.clone_from(repo_url, full_dest, **kwargs)

        return {
            "success": True,
            "dest": full_dest,
            "branch": repo.active_branch.name if not repo.head.is_detached else "detached",
            "error": None,
        }
    except (GitCommandError, NoSuchPathError, InvalidGitRepositoryError) as e:
        return {"success": False, "dest": dest, "error": str(e)}

@tool("extract_git_repository_details")
async def extract_repository_details(
    local_repository_path: Optional[str],
    github_url: Optional[str] = None,
    output_path: Optional[str] = GITINGEST_DEFAULT_OUTPUT_LOCATION,
) -> Dict[str, Any]:
    """
    Extract and ingest a Git repository (local or remote) into a readable LLM format.

    Args:
        local_repository_path: Path to a local repository directory.
        github_url: HTTPS URL of a remote GitHub repository.
        output_path: Output path for the extraction
            (default: "extract_repository_details.json" (GITINGEST_DEFAULT_OUTPUT_LOCATION),
            use "-" or "stdout" for stdout).
    Returns:
        path to a JSON dict with summary (str), tree (str), and content (str) of the repository.
    """

    try:
        exclude_patterns = {
            "*.pyc",
            "__pycache__",
            ".git",
            ".venv",
            "venv",
            "env",
            "node_modules",
            ".DS_Store",
            "*.log",
            ".pytest_cache",
            "*.egg-info",
            "dist",
            "build",
            "*.lock",
            ".pylintrc"
        }
        if local_repository_path is not None:
            path = local_repository_path
        elif github_url:
            path = github_url
        else:
            return {"success": False,
                    "error": "Either local_repository_path or github_url must be provided"
                }

        summary, tree, content = await ingest_async(
                path,
                exclude_patterns=exclude_patterns,
                output=output_path
        )
        extraction = {"summary": summary, "tree": tree, "content": content}

        if output_path in ["-", "stdout"]:
            print(json.dumps(extraction, ensure_ascii=False, indent=2))
            return {"success": True, "data": extraction}

        if output_path is not None:
            with open(output_path, "w", encoding="utf-8") as f:
                json.dump(extraction, f, ensure_ascii=False, indent=2)
            return {"success": True, "path": output_path}

        return {"success": True, "data": extraction}

    except Exception as e:
        return {"success": False, "error": str(e)}

@tool("load_extracted_repository")
def load_extracted_repository(
    path: str,
    include_summary: bool = True,
    include_tree: bool = True,
    include_content: bool = True
) -> Dict[str, Any]:
    """
    Load the extracted repository details from a file.
    This file is expected to be generated by the `extract_repository_details` tool.

    Args:
        path: Path to the file containing the extracted repository details.
        include_summary: If True, include the summary in the response.
        include_tree: If True, include the tree structure in the response.
        include_content: If True, include the file contents in the response.

    Returns:
        A dict with the loaded repository details containing the requested parts:
        - summary (str): Overview of the repository (if include_summary=True)
        - tree (str): Directory structure (if include_tree=True)
        - content (str): File contents (if include_content=True)
    """
    if not os.path.exists(path):
        return {"success": False, "error": "File not found"}

    try:
        with open(path, "r", encoding="utf-8") as f:
            data = json.load(f)

        result = {"success": True}

        if include_summary and "summary" in data:
            result["summary"] = data["summary"]

        if include_tree and "tree" in data:
            result["tree"] = data["tree"]

        if include_content and "content" in data:
            result["content"] = data["content"]

        return result

    except json.JSONDecodeError:
        return {"success": False, "error": "Invalid JSON format in file"}
    except Exception as e:
        return {"success": False, "error": f"Error loading file: {str(e)}"}
